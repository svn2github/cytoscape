/* -*-Java-*-
********************************************************************************
*
* File:         DefaultCytoscapeEditor.java
* RCS:          $Header: $
* Description:
* Author:       Allan Kuchinsky
* Created:      Sun Oct 04 05:35:56 2005
* Modified:     Tue Dec 02 18:16:25 2008 (Michael L. Creech) creech@w235krbza760
* Language:     Java
* Package:
* Status:       Experimental (Do Not Distribute)
*
* (c) Copyright 2006, Agilent Technologies, all rights reserved.
*
********************************************************************************
*
* Revisions:
*
* Tue Dec 02 18:15:52 2008 (Michael L. Creech) creech@w235krbza760
*  Added arrowShapeToArrow() and fixed bug where an ArrowShape was
*  being given to CytoShapeIcon constructor.
* Fri Jun 29 09:24:02 2007 (Michael L. Creech) creech@w235krbza760
*  Removed deprecated use in getNodeShape() and getFillColor() in
*  generateNodePaletteEntries().
* Thu May 10 09:37:06 2007 (Michael L. Creech) creech@w235krbza760
*  Updated to use VisualPropertyType versus VizMapUI for Cytoscape 2.5.
* Sun Dec 17 05:36:01 2006 (Michael L. Creech) creech@w235krbza760
*  Added creation of EdgePaletteItemDragCursorSetter and passing it into
*  ShapePalette.addShape() calls.
********************************************************************************
*/

/*
 * TODO To change the template for this generated file go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
package cytoscape.editor.editors;

import giny.view.NodeView;

import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Point;
import java.awt.dnd.DragSource;
import java.awt.dnd.DragSourceDragEvent;
import java.util.Iterator;
import java.util.List;

import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import cytoscape.Cytoscape;
import cytoscape.editor.CytoscapeEditorFactory;
import cytoscape.editor.CytoscapeEditorManager;
import cytoscape.editor.DragSourceContextCursorSetter;
import cytoscape.editor.ShapePaletteInfo;
import cytoscape.editor.ShapePaletteInfoGenerator;
import cytoscape.editor.event.PaletteNetworkEditEventHandler;
import cytoscape.editor.impl.CytoShapeIcon;
import cytoscape.editor.impl.ShapePalette;
import cytoscape.view.CyNetworkView;
import cytoscape.visual.Arrow;
import cytoscape.visual.ArrowShape;
import cytoscape.visual.EdgeAppearanceCalculator;
import cytoscape.visual.NodeAppearanceCalculator;
import cytoscape.visual.NodeShape;
import cytoscape.visual.VisualPropertyType;
import ding.view.DGraphView;


/**
 * /** An example editor that extends the basic Cytoscape editor and is based
 * upon a drag-and-drop and palette framework into which developers plug in
 * semantics. The framework consists of
 * <ul>
 * <li> a palette, from which the user drags and drops shapes onto the canvas
 * <li> an extensible shape class for the palette,
 * <li> a drawing canvas upon which shapes are dropped, and
 * <li> event handlers which respond to drop events generated by the canvas.
 * </ul>
 * <p>
 * The dropping of shapes onto the canvas results in the addition of nodes and
 * edges to the current Cytoscape network, as defined by the behavior of the
 * event handler that responds to the drop events.
 * <p>
 *
 *
 * @author Allan Kuchinsky
 * @version 1.0
 * @see PaletteNetworkEditEventHandler
 *
 */
public class DefaultCytoscapeEditor extends BasicCytoscapeEditor implements ChangeListener {

	/**
	 * main data structures for all node and edge attributes
	 */
	public static cytoscape.data.CyAttributes nodeAttribs = Cytoscape.getNodeAttributes();

	/**
	 * 
	 */
	public static cytoscape.data.CyAttributes edgeAttribs = Cytoscape.getEdgeAttributes();
	private ShapePalette shapePalette;

	// MLC 12/16/06 BEGIN:
	// Determine how edge palette items show up during a drag op:
	private DragSourceContextCursorSetter _edgeCursorSetter = new EdgePaletteItemDragCursorSetter();

	// MLC 12/16/06 END.
	/**
	 *
	 */
	public DefaultCytoscapeEditor() {
		super();
	}

	// MLC 12/02/06 BEGIN:
	/**
	     * specialized initialization code for editor, called by
	     * CytoscapeEditorManager when a new editor is built.
	     * draws shapes on the palette, based upon the visual style
	     *
	     * @param args
	     *            an arbitrary list of arguments passed to initialization
	     *            routine. Not used in this editor
	     */
	public void initializeControls(List args) {
		shapePalette = CytoscapeEditorManager.getCurrentShapePalette();
		shapePalette.clear();
		generatePaletteEntries();
		shapePalette.showPalette();
		super.initializeControls(null);
	}

	protected void generatePaletteEntries() {
		CytoscapeEditorManager.log("generating palette entries for controlling attributes "
		                           + getControllingNodeAttribute() + " and "
		                           + getControllingEdgeAttribute());
		CytoscapeEditorManager.log("for editor " + this);
		generateEdgePaletteEntries(getControllingEdgeAttribute());
		generateNodePaletteEntries(getControllingNodeAttribute());
	}

	protected void generateEdgePaletteEntries(String controllingAttribute) {
		EdgeAppearanceCalculator eac = Cytoscape.getVisualMappingManager().getVisualStyle()
		                                        .getEdgeAppearanceCalculator();

		if (eac == null) {
			return;
		}

		// CytoscapeEditorManager.log("Got edgeAppearanceCalculator: " + eac);		
		ShapePaletteInfoGenerator palGen = CytoscapeEditorFactory.INSTANCE
		                                                                                                                                                       .createShapePaletteInfoGenerator();

		VisualPropertyType[] calcsToUse = new VisualPropertyType [] { VisualPropertyType.EDGE_TGTARROW_SHAPE };

		Iterator<ShapePaletteInfo> spEntries = palGen.buildShapePaletteInfo(eac, calcsToUse,
		                                                                    controllingAttribute,
		                                                                    this, null);
		
		CytoscapeEditorManager.log("any edge types for shape palette? " + spEntries.hasNext());

		if (!spEntries.hasNext()) {
			shapePalette.addShape(controllingAttribute, "DirectedEdge",
					      // MLC 10/24/07:
			                      // new CytoShapeIcon(Arrow.DELTA), "Directed Edge",
					      // MLC 10/24/07:
			                      new CytoShapeIcon(Arrow.NONE), "Directed Edge",
			_edgeCursorSetter);
		} else {
			while (spEntries.hasNext()) {
				ShapePaletteInfo spi = spEntries.next();
				shapePalette.addShape(spi.getControllingAttributeName(), spi.getKey(),
						      // MLC 05/09/07:
				                      // new CytoShapeIcon((Arrow) spi.getValue(VizMapUI.EDGE_TGTARROW)),
						      // MLC 12/02/08 BEGIN:
				                      // new CytoShapeIcon((Arrow) spi.getValue(VisualPropertyType.EDGE_TGTARROW_SHAPE)),
						      new CytoShapeIcon(arrowShapeToArrow((ArrowShape) spi.getValue(VisualPropertyType.EDGE_TGTARROW_SHAPE))),
						      // MLC 12/02/08 END.
				                      spi.getKey(), // MLC 12/16/06:
				_edgeCursorSetter);
			}
		}
	}

    // MLC 12/02/08 BEGIN:
    protected Arrow arrowShapeToArrow(ArrowShape as) {
        if (as == ArrowShape.ARROW) {
            return Arrow.ARROW;
        } else if (as == ArrowShape.CIRCLE) {
            return Arrow.CIRCLE;
        } else if (as == ArrowShape.DELTA) {
            return Arrow.DELTA;
        } else if (as == ArrowShape.DIAMOND) {
            return Arrow.DIAMOND;
        } else if (as == ArrowShape.NONE) {
            return Arrow.NONE;
        } else if (as == ArrowShape.T) {
            return Arrow.T;
        }

        return null;
    }
    // MLC 12/02/08 END

	protected void generateNodePaletteEntries(String controllingAttribute) {
		NodeAppearanceCalculator nac = Cytoscape.getVisualMappingManager().getVisualStyle()
		                                        .getNodeAppearanceCalculator();

		if (nac == null) {
			return;
		}

		ShapePaletteInfoGenerator palGen = CytoscapeEditorFactory.INSTANCE
		                                                                                                                                                                                          .createShapePaletteInfoGenerator();
		VisualPropertyType[] calcsToUse = new VisualPropertyType[] { VisualPropertyType.NODE_FILL_COLOR, VisualPropertyType.NODE_SHAPE, VisualPropertyType.NODE_SIZE };
		Iterator<ShapePaletteInfo> spEntries = palGen.buildShapePaletteInfo(nac, calcsToUse,
		                                                                    controllingAttribute,
		                                                                    this, null);

		if (!spEntries.hasNext()) {
			shapePalette.addShape(controllingAttribute, "DefaultNode",
					      // MLC 06/30/07 BEGIN:
			                      // new CytoShapeIcon(nac.getDefaultAppearance().getNodeShape(),
					      //                   nac.getDefaultAppearance().getFillColor()),
			                      new CytoShapeIcon((NodeShape)(nac.getDefaultAppearance().get (VisualPropertyType.NODE_SHAPE)),
			                                        (Color)(nac.getDefaultAppearance().get (VisualPropertyType.NODE_FILL_COLOR))),
								// MLC 06/30/07 END.
								"Add a Node", // MLC 12/16/06:
								null);
		} else {
			while (spEntries.hasNext()) {
				ShapePaletteInfo spi = spEntries.next();

				Color nodeColor = (Color) spi.getValue(VisualPropertyType.NODE_FILL_COLOR);
				NodeShape nodeShape = (NodeShape) spi.getValue(VisualPropertyType.NODE_SHAPE);
				int nodeSize = (int) ((Double) spi.getValue(VisualPropertyType.NODE_SIZE)).longValue();
				// MLC 05/09/07 END.
				shapePalette.addShape(spi.getControllingAttributeName(), spi.getKey(),
				                      new CytoShapeIcon(nodeShape, nodeColor,
				                                        new Dimension(nodeSize, nodeSize)),
				                      spi.getKey(), // MLC 12/16/06:
				null);
			}
		}
	}

	protected ShapePalette getShapePalette() {
		return shapePalette;
	}

	/**
	 * sets controls invisible when editor type is switched
	 *
	 * @param args
	 *            args an arbitrary list of arguments (not used in this editor)
	 */
	public void disableControls(List args) {
		// super.disableControls(args);
		if (shapePalette != null) {
			shapePalette.setVisible(false);
		}
	}

	/**
	 * sets controls visible when editor type is switched back to this editor
	 *
	 * @param args
	 *            args an arbitrary list of arguments (not used in this editor) *
	 */
	public void enableControls(List args) {
		// super.enableControls(args);
		shapePalette.showPalette();
		shapePalette.setVisible(true);
	}

	/**
	 * redraw palette when a shape, color, or arrow mapping changes
	 *
	 * @param e
	 */
	public void stateChanged(ChangeEvent e) {
		initializeControls(null);
	}

	// MLC 12/16/06 BEGIN:
	// give sublcasses access to the default setter for edge palette entries:
	protected DragSourceContextCursorSetter getDefaultEdgePaletteItemDragCursorSetter() {
		return _edgeCursorSetter;
	}

	// A CursorSetter that says it's only ok to drop when we are on a Node:
	private class EdgePaletteItemDragCursorSetter implements DragSourceContextCursorSetter {
		public Cursor computeCursor(CyNetworkView netView, Point netViewLoc,
		                            DragSourceDragEvent dsde) {
			// Now check if we are on a NodeView?
			NodeView nv = ((DGraphView) netView).getPickedNodeView(netViewLoc);

			if (nv != null) {
				return DragSource.DefaultCopyDrop;
			}

			return DragSource.DefaultCopyNoDrop;
		}
	}

	// MLC 12/16/06 END.
}
