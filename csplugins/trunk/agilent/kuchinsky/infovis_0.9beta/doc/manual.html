<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>The InfoVis Toolkit</title><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="the-infovis-toolkit"></a>The InfoVis Toolkit</h1></div><div><div class="author"><h3 class="author"><span class="firstname">Jean-Daniel</span> <span class="surname">Fekete</span></h3><div class="affiliation"><span class="orgname">INRIA<br></span><div class="address"><p>Jean-Daniel.Fekete@inria.fr</p></div></div></div></div><div><p class="copyright">Copyright © 2003, 2004 INRIA</p></div><div><div class="legalnotice"><p>The contents of this book can be freely used and distributed
    as far as the source is mentioned as a reference that is, its URL:
    <a href="http://www.lri.fr/~fekete/InfovisToolkit/manual.html" target="_top">http://www.lri.fr/~fekete/InfovisToolkit/manual.html</a>.</p></div></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="2"><b>Revision History</b></th></tr><tr><td align="left">Revision 0.4</td><td align="left">March 2004</td></tr><tr><td align="left" colspan="2">Extended the tutorial and installation instructions.</td></tr><tr><td align="left">Revision 0.3</td><td align="left">February 2004</td></tr><tr><td align="left" colspan="2">Updated to release 0.6 of the Toolkit</td></tr><tr><td align="left">Revision 0.2</td><td align="left">October 2003</td></tr><tr><td align="left" colspan="2">Description of columns, Metadata and tables.</td></tr><tr><td align="left">Revision 0.1</td><td align="left">January 2003</td></tr><tr><td align="left" colspan="2">Start of document</td></tr></table></div></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#id4691674">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#sec_installing">Installing the InfoVis Toolkit</a></span></dt><dt><span class="section"><a href="#sec_sample_data">Sample Data and File Formats</a></span></dt><dt><span class="section"><a href="#sec_file_formats">Supported File Formats</a></span></dt></dl></dd><dt><span class="chapter"><a href="#id4743967">2. Tutorial</a></span></dt><dd><dl><dt><span class="section"><a href="#sec_starting_infovis">Starting with the InfoVis Toolkit</a></span></dt><dt><span class="section"><a href="#sec_organization">Organization of the InfoVis Toolkit</a></span></dt><dt><span class="section"><a href="#sec_visualizing_tree">Carrying on: Visualizing a Tree as a Treemap</a></span></dt><dt><span class="section"><a href="#sec_spec_visual_attr">Specifying Visual Attributes</a></span></dt><dt><span class="section"><a href="#sec_using_fisheyes">Using Fisheye Lenses or Dynamic Labeling</a></span></dt><dt><span class="section"><a href="#sec_creating_managing_ds">Creating and Managing Data Structures</a></span></dt><dd><dl><dt><span class="section"><a href="#sec_managing_tables">Managing Tables</a></span></dt></dl></dd><dt><span class="section"><a href="#sec_managing_trees">Managing Trees</a></span></dt><dt><span class="section"><a href="#sec_managing_graphs">Managing Graphs</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap_data_structures">3. Data Structures</a></span></dt><dd><dl><dt><span class="section"><a href="#sec_columns">Columns</a></span></dt><dd><dl><dt><span class="section"><a href="#id4745096">Presentation Format</a></span></dt><dt><span class="section"><a href="#id4745238">NumberColumns</a></span></dt><dt><span class="section"><a href="#id4745336">Dense Columns</a></span></dt><dt><span class="section"><a href="#id4745447">Sparse Columns</a></span></dt><dt><span class="section"><a href="#id4745457">Column Dependencies</a></span></dt></dl></dd><dt><span class="section"><a href="#sec_tables">Tables</a></span></dt><dt><span class="section"><a href="#sec_tree">Trees</a></span></dt><dt><span class="section"><a href="#sec_graphs">Graphs</a></span></dt><dt><span class="section"><a href="#sec_metadata">Metadata</a></span></dt><dd><dl><dt><span class="section"><a href="#id4745955">Standard Description</a></span></dt><dt><span class="section"><a href="#id4745973">Aggregation</a></span></dt><dt><span class="section"><a href="#id4746375">Converting to Number Columns</a></span></dt><dt><span class="section"><a href="#id4746384">Color Scheme Categories</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chap_visualizations">4. Visualizations</a></span></dt><dd><dl><dt><span class="section"><a href="#id4746460">Implementation of the Visualization Classes</a></span></dt><dd><dl><dt><span class="section"><a href="#id4746771">Displaying Items in Visualizations</a></span></dt><dt><span class="section"><a href="#id4747074">Visual Column Management</a></span></dt><dt><span class="section"><a href="#sec_color">Color Management</a></span></dt><dt><span class="section"><a href="#id4747106">Picking</a></span></dt></dl></dd><dt><span class="section"><a href="#id4747117">Table Visualizations</a></span></dt><dt><span class="section"><a href="#id4747126">Stroking and Link Visualizations</a></span></dt><dt><span class="section"><a href="#id4747136">Tree Visualizations</a></span></dt><dt><span class="section"><a href="#id4747146">Graph Visualizations</a></span></dt><dt><span class="section"><a href="#id4747155">Dynamic Labeling</a></span></dt><dt><span class="section"><a href="#id4747165">Fisheye Lenses</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap_interaction">5. Interaction</a></span></dt><dd><dl><dt><span class="section"><a href="#id4747190">Dynamic Queries</a></span></dt></dl></dd><dt><span class="chapter"><a href="#readerswriters">6. Readers and Writers</a></span></dt><dd><dl><dt><span class="section"><a href="#id4747213">Table Readers and Writers</a></span></dt><dt><span class="section"><a href="#id4747222">Tree Readers and Writers</a></span></dt><dt><span class="section"><a href="#id4747232">Graph Readers and Writers</a></span></dt></dl></dd><dt><span class="chapter"><a href="#id4747242">7. Design Patterns</a></span></dt><dd><dl><dt><span class="section"><a href="#id4747250">Abstract Factory</a></span></dt><dt><span class="section"><a href="#id4747260">Observer</a></span></dt><dt><span class="section"><a href="#id4747269">Visitor</a></span></dt></dl></dd><dt><span class="index"><a href="#id4747282">Index</a></span></dt></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>1.1. <a href="#id4685147">Examples of Visualizations Provided by the InfoVis
   Toolkit</a></dt><dt>3.1. <a href="#fig_table">The Table interface</a></dt><dt>3.2. <a href="#fig_tree">The Tree interface</a></dt><dt>3.3. <a href="#fig_graph">The Graph interface</a></dt></dl></div><div class="list-of-examples"><p><b>List of Examples</b></p><dl><dt>2.1. <a href="#ex1_1">Simple visualization program for time series data</a></dt><dt>2.2. <a href="#ex1_2">Simple visualization program for hierarchical data</a></dt><dt>3.1. <a href="#ex2_1">Creating a LongColumn Reading Dates
     in the Unix Format </a></dt></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id4691674"></a>Chapter 1. Introduction</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#sec_installing">Installing the InfoVis Toolkit</a></span></dt><dt><span class="section"><a href="#sec_sample_data">Sample Data and File Formats</a></span></dt><dt><span class="section"><a href="#sec_file_formats">Supported File Formats</a></span></dt></dl></div><p>The InfoVis toolkit is a software package aimed at simplifying
   the development of Information Visualization Systems.  It is
   written in Java, capitalizing on its rich interactive graphics
   environment and portability. </p><p>Information Visualization is a domain that emerged in the
   early 1990 and has expanded at a steady pace since then, showing
   great results, innovative concepts and techniques.  So many
   concepts and techniques that it is challenging to keep pace with
   the implementation of the most useful techniques.  The InfoVis
   toolkit is designed to be a repository of know-how for building
   highest quality information visualization systems.</p><p>Practically, visualizations translate data items into visual
  marks.  Data items are made of typed data attributes organized in a
  data structure, such as employee records in a table, or files in a
  hierarchical file system.  Visual marks are eventually made of
  colored pixels on a screen, but can more accurately be described as
  geometric entities displayed with graphical attributes such as color
  or transparency.  A visualization technique consists in translating
  each data item into a geometry and related graphical attributes to
  draw them on screen in a specified order.  The visualization toolkit
  provides several visualization techniques for three main data
  structures: tables, trees and graphs. It also provides mechanisms to
  add visualization techniques and data structures.</p><div class="figure"><a name="id4685147"></a><p class="title"><b>Figure 1.1. Examples of Visualizations Provided by the InfoVis
   Toolkit</b></p><div class="screenshot"><div><img src="scatterplot-small.png" alt="Examples of Visualizations Provided by the InfoVis Toolkit"></div></div><div class="screenshot"><div><img src="nbatreemap-small.png" alt="Examples of Visualizations Provided by the InfoVis Toolkit"></div></div><div class="screenshot"><div><img src="htmlgraph-small.png" alt="Examples of Visualizations Provided by the InfoVis Toolkit"></div></div></div><p>Visualizations also involves <span class="emphasis"><em>interacting</em></span>
  with the visualized items and the data structures.  Interactions
  include navigation into the data structure &#8212; including
  zooming, dynamically filtering visualized items &#8212; including
  dynamic queries, and various dynamic techniques such as space
  deformations using fisheye lenses or dynamic labeling.  The
  visualization toolkit provides several techniques for interacting
  with the visualizations and mechanisms to add new interaction
  techniques.</p><p>Interacting with visualizations require stringent constraints
  on time.  Dynamic updates of visualization should be performed in
  less than 100ms to appear smooth and continuous.  This constraint
  requires the data structures to be organized in memory in a way
  specially crafted for fast access.  The visualization toolkit
  provides homogeneous data structures to store visualization data
  into memory.  All data structures are represented as tables of
  columns.  Each column contain data of homogeneous data type such as
  integers, floating point values or strings.  This mechanism allows
  new columns to be added to existing data structures, allowing new
  attributes to be computed and used to enrich visualizations in a
  uniform way.</p><p>This document is both a tutorial and a user's manual.  The
   reference information can be found on the HTML descriptions produced
   by Javadoc and will keep synchronized with the code more closely
   than this manual.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_installing"></a>Installing the InfoVis Toolkit</h2></div></div><div></div></div><p>The InfoVis Toolkit is a Java library, designed to work with
   Java/Swing components.  It requires a Java 1.4 runtime or above for
   running the library programs and examples. A Java compiler is
   required to create applications using the InfoVis Toolkit.

   The InfoVis Toolkit is composed of one main library jar file
   called infovis.jar and several supporting libraries and programs.
   A sample application can be run using directly from the infovis.jar
    library using the following command, assuming the file infovis.jar
   is in the current directory: "java -jar infovis.jar"</p><p>To compile applications or examples using the InfoVis
   Toolkit, the file infovis.jar should be added to the Java class
   path.  This is generally done using an option of you favorite IDE
   for Java or by setting the shell variable CLASSPATH to the location
   of the file <tt class="filename">infovis.jar</tt>.  Furthermore, you
   need to have other library files available to run the InfoVis
   Toolkit, all distributed with the InfoVis Toolkit in the "lib"
   directory:</p><div class="variablelist"><dl><dt><span class="term"><tt class="filename">agile2d.jar</tt> and
      <tt class="filename">agile2d_opengl.jar</tt></span></dt><dd><p>Agile2D library files.  These files are used by the
      InfoVis Toolkit to support hardware accelerated graphics when
      available.  See <a href="http://www.cs.umd.edu/hcil/agile2d" target="_top">the official site of
      Agile2D</a>.
      </p></dd><dt><span class="term">antlrall.jar</span></dt><dd><p>ANTLR library file, used to parse some complex file
      formats such as the Newick Tree format or the DOT Graph
       format.  See <a href="http://www.antlr.org" target="_top">the official
      site of ANTLR</a>.</p></dd><dt><span class="term"><tt class="filename">gl4java.jar</tt>,
      <tt class="filename">gl4java-glffonts.jar</tt> and
      <tt class="filename">gl4java-glutfonts.jar</tt></span></dt><dd><p>The Gl4java library files.  These files are used by
      Agile2D to access the OpenGL low level library of hardware
      accelerated graphics.  gl4java can be downloaded at <a href="http://www.jausoft.com/products/gl4java/gl4java_main.html" target="_top">
      http://www.jausoft.com/products/gl4java/gl4java_main.html</a></p></dd><dt><span class="term"><tt class="filename">png.jar</tt></span></dt><dd><p>Library allowing the loading of image file of type PNG.</p></dd><dt><span class="term"><tt class="filename">xml-writer.jar</tt></span></dt><dd><p>A library simplifying the writing of XML files following
      the syntactic conventions of XML.  This library is used for XML
      file writers.</p></dd></dl></div><p>Furthermore, some programs are used by the toolkit to layout
    graphs: <span class="application">dot</span>,
    <span class="application">neato</span> and
    <span class="application">twopi</span>.  These programs are provided by
    the GraphViz package of AT&amp;T, available at <a href="http://www.graphviz.org" target="_top">the official site of
    GraphViz</a>.  These programs should be in the executable PATH
    because they will be called from the InfoVis Toolkit when graph
    layout is used.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_sample_data"></a>Sample Data and File Formats</h2></div></div><div></div></div><p>The InfoVis Toolkit is distributed with a set of sample data
   files to try and test the toolkit or user applications.  They are
   also used as examples of the file formats supported. </p><div class="variablelist"><dl><dt><span class="term"><tt class="filename">52weeks.tqd</tt> and
     <tt class="filename">salivary.tqd</tt></span></dt><dd><p>Time series data provided by Harry Hochheiser from the
      University of Maryland.  The TQD format is a variant of the CSV
      format used by <span class="application">Excel</span> and similar
      applications.</p></dd><dt><span class="term"><tt class="filename">ABCYIM.clustalw</tt> and
     <tt class="filename">ABCYabc.clustalw</tt></span></dt><dd><p>Phylogenetic trees in Newick format, used by the InfoVis
      2003 Contest and provided by Elie Dassa from Institut Pasteur,
      France.</p></dd><dt><span class="term"><tt class="filename">ABCYIM.xml</tt> and
     <tt class="filename">ABCYabc.xml</tt></span></dt><dd><p>Phylogenetic trees in XML format, same as previous files
      in another format.</p></dd><dt><span class="term"><tt class="filename">election.tm3</tt> and
     <tt class="filename">nba.tm3</tt></span></dt><dd><p>Analysis data for the USA 2002 elections in a tree format,
       by region and state.  These file are part of the
       <span class="application">Treemap4</span> distribution from the
       University of Maryland. </p></dd><dt><span class="term"><tt class="filename">nodelinktest.xml</tt>,
      <tt class="filename">testtree.xml</tt>,
      <tt class="filename">testtreeml.xml</tt> and
      <tt class="filename">tree3.xml</tt></span></dt><dd><p>Various trees in XML using the treeml dtd provided in the
      same directory.</p></dd><dt><span class="term"><tt class="filename">jsort.dot</tt> and
     <tt class="filename">testgraph2.dot</tt></span></dt><dd><p>Graphs in the DOT format. The first graph is distributed
      with the GraphViz system and the second is a sample graph
       provided for testing.  The file
       <tt class="filename">jsort.out.dot</tt> provides the graph
       <tt class="filename">jsort.dot</tt> graph positioned by the
       <span class="application">dot</span> program.</p></dd><dt><span class="term"><tt class="filename">testgraph.xml</tt> and
     <tt class="filename">testgraph2.xml</tt></span></dt><dd><p>Two graphs using the GraphML DTD provided in the same
      directory. </p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_file_formats"></a>Supported File Formats</h2></div></div><div></div></div><p>The InfoVis Toolkit supports a limited but extensible set of
    file formats.  Section <a href="#readerswriters" title="Chapter 6. Readers and Writers">Chapter 6, <i>Readers and Writers</i></a> explains
   how file formats are read and written and how to extend the list of
   supported file formats.</p><div class="variablelist"><dl><dt><span class="term">CSV Format</span></dt><dd><p>Format used by <span class="application">Excel</span> and
      similar programs to export files using a readable format.  CSV
      files contain tabular organized as lines, each element separated
      by a specific character.  The InfoVis Toolkit reader for CSV
      file can be configured to read any delimiter but, for by
      default, the separator is the semicolon character.</p><p>On some CSV files, the first line contain the names of the
      columns.  The CSV reader can be configured to read them
      accordingly.  On some file also, the second line contain column
      type names such as "integer" or "string".  The CSV reader can
      also be configured to take that line into account.</p><p>Finally, some CSV files use initial lines for heading
      information not relevant to the table.  the CSV reader can be
      configured to skip a specified number of initial lines.</p><p>So far, all these configurations should be specified by
      program.  A useful extension to the toolkit would allow a user
      to load a file an specify interactively the right parameters to
      load any kind of CSV file, but this module remains to be done.
      Meanwhile, applications should configure the loader
      programmatically.</p><p>Many file readers use that format as a base.
       This format supports an arbitrary number of attributes
      associated with table rows.</p></dd><dt><span class="term">XML format</span></dt><dd><p>XML is a meta-syntax for describing data files.  The
      InfoVis Toolkit supports several instances of XML documents for
      all its data types.  XML specific syntaxes is specified inside
      XML files using a DTD declaration usually or a starting "tag"
      expressing its contents.  The InfoVis Toolkit recognizes some
      specific XML syntaxes and can load any XML files as a tree.</p></dd><dt><span class="term">TQD</span></dt><dd><p>The TQD format is a variant of the CSV format using some
      initial lines to describe the file contents and a coma as column
      separator.  You should take a look at the sample files for more
      hints about the format.</p></dd><dt><span class="term">Newick format</span></dt><dd><p>The Newick format is used in Biology to describe
      phylogenetic trees.  It is a weird parenthesized format
      described at this url: <a href="http://evolution.genetics.washington.edu/phylip/newicktree.html" target="_top">http://evolution.genetics.washington.edu/phylip/newicktree.html</a>.</p><p>This format supports a limited number of attributes
      associated with nodes.</p></dd><dt><span class="term">TM3 format</span></dt><dd><p>The TM3 format is the internal format used by the
       <span class="application">Treemap4</span> program.  It is a variant
       of the CSV format, using the TAB character as separator.  Its
       first line contains the column names, the second line contains
       the column types. The remaining lines contain one entry per
       tree node.  The path of the node is encoded after the last
       column, following two TAB characters. It contains the path to
       the node: the first name is the name of the root node, the
       second name is a child of the root node etc.</p><p>This format supports an arbitrary number of attributes
      associated with tree nodes.</p></dd></dl></div><div class="variablelist"><dl><dt><span class="term">The DOT format</span></dt><dd><p>Format used by the GraphViz applications to represent
      graphs.  It is readable, supports an arbitrary number of
      attributes although some of these attributes have a meaning for
      the layout algorithms and cannot be used with an arbitrary
      meaning.</p></dd><dt><span class="term">The XML TreeML DTD</span></dt><dd><p>An XML DTD has been developed for describing general
       trees, mainly for the InfoVis 2004 Contest.  The
       <tt class="filename">treeml.dtd</tt> file contains a good
       description of its elements and several files show samples of
       the format.</p><p>This format supports an arbitrary number of attributes
      associated with tree nodes.</p></dd><dt><span class="term">The XML GraphML DTD</span></dt><dd><p>The GraphML format is meant for exchanging graphs.  It is
       described in <a href="http://graphml.graphdrawing.org" target="_top">http://graphml.graphdrawing.org</a>. The
       InfoVis Toolkit implements it partially.</p><p>This
       format supports an arbitrary number of attributes associated
       with vertices and edges.</p></dd></dl></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id4743967"></a>Chapter 2. Tutorial</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#sec_starting_infovis">Starting with the InfoVis Toolkit</a></span></dt><dt><span class="section"><a href="#sec_organization">Organization of the InfoVis Toolkit</a></span></dt><dt><span class="section"><a href="#sec_visualizing_tree">Carrying on: Visualizing a Tree as a Treemap</a></span></dt><dt><span class="section"><a href="#sec_spec_visual_attr">Specifying Visual Attributes</a></span></dt><dt><span class="section"><a href="#sec_using_fisheyes">Using Fisheye Lenses or Dynamic Labeling</a></span></dt><dt><span class="section"><a href="#sec_creating_managing_ds">Creating and Managing Data Structures</a></span></dt><dd><dl><dt><span class="section"><a href="#sec_managing_tables">Managing Tables</a></span></dt></dl></dd><dt><span class="section"><a href="#sec_managing_trees">Managing Trees</a></span></dt><dt><span class="section"><a href="#sec_managing_graphs">Managing Graphs</a></span></dt></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_starting_infovis"></a>Starting with the InfoVis Toolkit</h2></div></div><div></div></div><p>Several sample applications of the InfoVis Toolkit are
    provided in the example folder in the distribution.  Visualizing a
    table as a time-series data can be done as follows:</p><div class="example"><a name="ex1_1"></a><p class="title"><b>Example 2.1. Simple visualization program for time series data</b></p><pre class="programlisting">public class Example1 {
    public static void main(String args[]) {
        String fileName =
            (args.length == 0) ? "data/salivary.tqd" : args[0];
        DefaultTable t = new DefaultTable();
        t.setName(fileName);
        AbstractReader reader =
            TableReaderFactory.createReader(fileName, t);
        if (reader == null || !reader.load()) {
            System.err.println("cannot load " + fileName);
            return;
        }
        TimeSeriesVisualization visualization =
            new TimeSeriesVisualization(t);
        VisualizationPanel panel =
            new VisualizationPanel(visualization);
            
        JFrame frame = new JFrame(fileName);
        frame.getContentPane().add(panel);
        frame.setVisible(true);
        frame.pack();
    }
}

    </pre></div><p>The package declarations have been omitted for clarity.  The
    main program creates and displays a simple time series
    visualization from the file name specified in the first argument
    of the program.  First, a table is created and named with the file
    name.  Loading the file is done in two steps: finding a reader and
    actually loading the file from this reader.  The reader is created
    through a <a class="indexterm" name="id4744022"></a>
    <span class="emphasis"><em>factory object</em></span>.  Factories are used to create
    objects indirectly according to some specified parameters (we will
    describe them later in depth). Here, a reader object is created
    from a file name and a table object.  The factory analyzes the
    file name and maybe the file contents to create the most suitable
    reader for it.  If no reader is returned or the reader cannot load
    the file, the program is exited with an error message.  Otherwise,
    a visualization object is created and inserted in a standard
    Java/Swing JFrame inside a visualization panel.
   </p><p>In this example, the visualization is not interactive because
   we haven't created any control panel associated with the
   visualization.  We can have the control panel if we replace the
   creation of the visualization panel by the following code:</p><pre class="programlisting">        ControlPanel panel =
            ControlPanelFactory.sharedInstance()
              .createControlPanel(visualization);

</pre><p>Factories are quite simple and very useful for extending the
    infovis toolkit.  They are simple objects with one creator method
    that looks at it arguments and create an object according to them.
    The TableReaderFactory looks at the file name and, if it recognizes
    that it ends with the ".csv" extension returns a new CSVTableReader.
    If it receives a file name ending with ".csv.gz", it recognizes that
    the file is compressed by GZIP and decompress is on the fly.  New
    file readers can then be defined by programmers and added to newer
    releases of the infovis toolkit and the same program will then be
    able to read these new file formats without modification.  Other
    kinds of customizations are allowed by the "factory" pattern but we
    will describe them on a separate section.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_organization"></a>Organization of the InfoVis Toolkit</h2></div></div><div></div></div><p>Although the InfoVis Toolkit may seem large by the number of
    classes it defines, it follows a very simple structure.  At the
    top-level, it defines the most important interfaces and classes:
    <tt class="classname">Column</tt>, <tt class="classname">Table</tt>,
    <tt class="classname">Tree</tt>, <tt class="classname">Graph</tt>,
    <tt class="classname">Visualization</tt> and
    <tt class="classname">Metadata</tt>.  The first-level defines the
    several column classes in the <tt class="filename">column</tt> package,
    basic input/output classes in the <tt class="filename">io</tt> package,
    several metadata categories in the <tt class="filename">metadata</tt>
    package, control panels and interaction components in the
    <tt class="filename">panel</tt> package, a
    <tt class="filename">visualization</tt> package for the visualization
    internals and subpackages for the data-structures:
    <tt class="filename">table</tt>, <tt class="filename">tree</tt> and
    <tt class="filename">graph</tt>.  Finally, a <tt class="filename">utils</tt>
    package contains utility classes that don't fit in other packages.
   </p><p>Each data-structure related package also contain sub-packages
    for their input/output components and their visualizations.  This
    is where the default readers and writers are defined, as well as
    the visualizations provided by default.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_visualizing_tree"></a>Carrying on: Visualizing a Tree as a Treemap</h2></div></div><div></div></div><p>To visualize a tree data-structure using the "Treemap"
    [<span class="citation"></span>] visualization technique, the code
    would be:</p><div class="example"><a name="ex1_2"></a><p class="title"><b>Example 2.2. Simple visualization program for hierarchical data</b></p><pre class="programlisting">import infovis.tree.DefaultTree;
import infovis.tree.io.TreeReaderFactory;
import infovis.tree.visualization.TreemapVisualization;
import infovis.io.AbstractReader;
import infovis.panel.ControlPanel;
import infovis.panel.ControlPanelFactory;

import javax.swing.JFrame;

public class Example2 {
    public static void main(String[] args) {
        String fileName =
            (args.length == 0) ? "data/salivary.tqd" : args[0];
        DefaultTree t = new DefaultTree();
        AbstractReader reader =
            TreeReaderFactory.createReader(fileName, t);
        if (reader == null || !reader.load()) {
            System.err.println("cannot load " + fileName);
        }

        TreemapVisualization visualization =
            new TreemapVisualization(t, null, Squarified.SQUARIFIED);
        ControlPanel control =
            ControlPanelFactory.sharedInstance().createControlPanel(
                visualization);

        JFrame frame = new JFrame(fileName);
        frame.getContentPane().add(control);
        frame.setVisible(true);
        frame.pack();
    }
}

    </pre></div><p>The package declaration for the program <a href="#ex1_1" title="Example 2.1. Simple visualization program for time series data">Example 2.1, &#8220;Simple visualization program for time series data&#8221;</a> is:</p><a name="ex1_3"></a><pre class="programlisting">import infovis.io.AbstractReader;
import infovis.table.DefaultTable;
import infovis.table.io.TableReaderFactory;
import infovis.table.visualization.TimeSeriesVisualization;
import infovis.panel.ControlPanel;
import infovis.panel.ControlPanelFactory;

import javax.swing.JFrame;
    
   </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_spec_visual_attr"></a>Specifying Visual Attributes</h2></div></div><div></div></div><p>Each visualization technique use a layout algorithm and
   several visual attributes to set the color or geometric properties
   of the displayed items.  For example, scatter plots compute the
   position of items based on two visual attributes: one for the X
   coordinate and one for the Y coordinate.  Each item can have a size
   and a color.  These visual attributes can be associated with data
   columns or set to default values.</p><p>Some visual attributes are generic to all visualizations and
   others are specific.  The generic attributes are color,
    label and size.  For example, if you know that the tree in example
   <a href="#ex1_2" title="Example 2.2. Simple visualization program for hierarchical data">Example 2.2, &#8220;Simple visualization program for hierarchical data&#8221;</a> has an column called "name", you can
   specify it as the label column like this:</p><a name="ex1_4"></a><pre class="programlisting">            visualization.setVisualColumn(
                Visualization.VISUAL_LABEL,
                t.getColumn("name"));
</pre><p>The label will then appear with a form depending on the
   visualization: inside items for scatter plots or trees.  If
   dynamic labels are enabled, they will use the content of this
   column for their labels.</p><p>Visualization technique may use additional visual attributes
   such as shape for scatter plots.  Some visual attributes, such as
   color and stroke, are defaulted when they not specified.  The
   default value can be set through the methods of the form:
   <tt class="methodname">setDefault&lt;ATTRIB&gt;(ATTRIB default)</tt>.
   </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_using_fisheyes"></a>Using Fisheye Lenses or Dynamic Labeling</h2></div></div><div></div></div><p>Allowing Fisheye Lenses is just a visualization
   option:</p><a name="ex1_6"></a><pre class="programlisting">
            visualization.setFisheyes(new Fisheyes());
</pre><p>Enabling Dynamic Labeling involves creating a new
    <a class="indexterm" name="id4744466"></a>
    visualization layer above the main visualization.  Here is the
    required code:</p><a name="ex1_5"></a><pre class="programlisting">
        TimeSeriesVisualization visualization =
            new TimeSeriesVisualization(t);
        ControlPanel control =
            ControlPanelFactory.sharedInstance().
                createControlPanel(excentric);
</pre><p>The toolkit provides higher-level mechanisms to create
   visualizations and display them using option panels allowing
   fisheye views and dynamic labeling to be enabled or disabled at
   will. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_creating_managing_ds"></a>Creating and Managing Data Structures</h2></div></div><div></div></div><p>The InfoVis Toolkit comes with three main data types suited
   to visualizations: tables, trees and graphs.  This section shows
   how to create and manage them.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sec_managing_tables"></a>Managing Tables</h3></div></div><div></div></div><p><tt class="classname">Table</tt> is the basic structure for
     storing data managed by the InfoVis Toolkit.  A Table is made of
     <tt class="classname">Column</tt>s.  Here is a example of table
     creation and initialization.  The table will be made of three
     columns called "name", "date" and "size":</p><a name="ex1_7"></a><pre class="programlisting">Table table = new DefaultTable();
StringColumn name = new StringColumn("name");
table.addColumn(name);
LongColumn date = new LongColumn("date");
table.addColumn(date);
IntColumn size = new IntColumn("size");
table.addColumn(size);
</pre><p>At this point, the table only contains columns, no
    values. To add two values to the table, the columns should be
    filled:</p><a name="ex1_8"></a><pre class="programlisting">
name.add("file1");
date.add(124334);
size.add(1024);
name.add("file2");
date.add(143434);
size.add(10);
</pre><p>Adding dates as long integer is not very convenient.
     Columns can convert strings into the values they hold using a
     <tt class="classname">Format</tt>:</p><a name="ex1_9"></a><pre class="programlisting">
date.setFormat(new UTCDateFormat());
name.add("file1");
date.addValue("03/23/2003 15:32:10");
size.add(1024);
name.add("file2");
date.addValue("03/10/2004 10:43:21");
size.add(10);
</pre><p>This syntax is much simpler to read and is also useful for
    reading from a data file.  Formats transform a string into a typed
    value and, on the other direction, transform an internal
    representation into an printable string.  Dates could be managed
     as Java Objects using an <tt class="classname">ObjectColumn</tt> but
    their memory footprint and speed would be much worse.  In general,
    it is wise to transform an external representation into the most
    suitable internal representation.  If you want to manage a table
    containing names that are categories, such as the days of the week
    or the states of the USA, you should use an IntColumn to hold the
     category number and use a
    <tt class="classname">CategoricalFormat</tt> to map from the category
    name to the category number in the column automatically.</p><p>Columns can have missing values.  Suppose your have a
    dataset containing a pollution value sent by a sensor every hour.
    If this sensor stops working properly and is fixed in four hours,
    your serial dataset will miss four values.  Here is an example of
    code that reads a file containing values where empty lines are
    considered missing values:</p><a name="ex1_10"></a><pre class="programlisting">IntColumn pollution = new IntColumn("pollution");
for (int i = 0; true; i++) {
    String line = input.readLine();
    if (line == null)
        break;
    if (line.length() != 0) {
        pollution.setValue(i, line);
    }
}
</pre><p>Once a table has been created and filled, it can be
    visualized.  The table can also be dynamically modified while it
    is visualized since columns implement a mechanism to notify
    interested objects when they are modified.  </p><p>Section <a href="#sec_tables" title="Tables">the section called &#8220;Tables&#8221;</a> provides all the
    details on manipulating tables.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_managing_trees"></a>Managing Trees</h2></div></div><div></div></div><p>Trees are data structures based on tables.  Here is an
    example of tree creation:</p><a name="ex1_11"></a><pre class="programlisting">Tree tree = new DefaultTree();
StringColumn name = new StringColumn("name");
tree.addColumn(name);
LongColumn date = new LongColumn("date");
tree.addColumn(date);
IntColumn size = new IntColumn("size");
tree.addColumn(size);
date.setFormat(new UTCDateFormat());
int node = tree.addNode(Tree.ROOT);
name.setValue(node, "file1");
date.setValue(node, "03/23/2003 15:32:10");
size.setExtend(node, 1024);
node = tree.addNode(Tree.ROOT);
name.setValue(node, "file2");
date.setValue(node, "03/10/2004 10:43:21");
size.setExtend(node,10);
</pre><p>This example is similar to the table example but instead of
    adding data in columns, it uses node numbers created by the tree
    as indexes. Contrary to the table example, the indexes returned by
    the tree method <tt class="methodname">addNode(int parent)</tt> can
    be in any order and the attribute values should be set at the node
    index.  This explains why we used the methods
    <tt class="methodname">setValue(int index, String v)</tt> and
    <tt class="methodname">setExtend(int index, TYPE v)</tt> instead of
    <tt class="methodname">addValue(String v)</tt> and
    <tt class="methodname">add(TYPE v)</tt> in the table example.</p><p>Section <a href="#sec_tree" title="Trees">the section called &#8220;Trees&#8221;</a> prodigies all the details
    on manipulating trees.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_managing_graphs"></a>Managing Graphs</h2></div></div><div></div></div><p>Graphs data structures are based on tables.  A graph is made
    of two tables: the vertex table and the edge table.  Here is an
    example of graph creation:</p><a name="ex1_12"></a><pre class="programlisting">Graph graph = new DefaultGraph();
StringColumn name = new StringColumn("name");
graph.getVertexTable().addColumn(name);
LongColumn date = new LongColumn("date");
graph.getVertexTable().addColumn(date);
IntColumn size = new IntColumn("size");
graph.getVertexTable().addColumn(size);
date.setFormat(new UTCDateFormat());
int v1 = graph.addVertex();
name.setValue(v1, "file1");
date.setValue(v1, "03/23/2003 15:32:10");
size.setExtend(v1, 1024);
int v2 = graph.addVertex();
name.setValue(v2, "file2");
date.setValue(v2, "03/10/2004 10:43:21");
size.setExtend(v2,10);

IntColumn refCount = new IntColumn("edgeCount");
graph.getEdgeTable().addColumn(refCount);
int e1 = graph.addEdge(v1, v2);
refCount.setExtend(e1, 1);
</pre><p>This example creates a new graph and adds the same three columns
    as in the previous examples to the vertex table.  It also creates
    a column name "refCount" associated with the edge table, so the
    graph has both attributes associated to its vertices ("name",
    "date" and "size") and to its edges ("refCount").</p><p>Section <a href="#sec_graphs" title="Graphs">the section called &#8220;Graphs&#8221;</a> provides all the details
    on manipulating graphs.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="chap_data_structures"></a>Chapter 3. Data Structures</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#sec_columns">Columns</a></span></dt><dd><dl><dt><span class="section"><a href="#id4745096">Presentation Format</a></span></dt><dt><span class="section"><a href="#id4745238">NumberColumns</a></span></dt><dt><span class="section"><a href="#id4745336">Dense Columns</a></span></dt><dt><span class="section"><a href="#id4745447">Sparse Columns</a></span></dt><dt><span class="section"><a href="#id4745457">Column Dependencies</a></span></dt></dl></dd><dt><span class="section"><a href="#sec_tables">Tables</a></span></dt><dt><span class="section"><a href="#sec_tree">Trees</a></span></dt><dt><span class="section"><a href="#sec_graphs">Graphs</a></span></dt><dt><span class="section"><a href="#sec_metadata">Metadata</a></span></dt><dd><dl><dt><span class="section"><a href="#id4745955">Standard Description</a></span></dt><dt><span class="section"><a href="#id4745973">Aggregation</a></span></dt><dt><span class="section"><a href="#id4746375">Converting to Number Columns</a></span></dt><dt><span class="section"><a href="#id4746384">Color Scheme Categories</a></span></dt></dl></dd></dl></div><p>Data structures define two things: a topology and data
   attributes.  Classical topologies include tables, trees and graphs.
   data attributes are usually defined as tuples associated with the
   topology.  For example, an employee data type can be described by a
   set of attributes such as "birth date", "first name", "last name",
   and "social security number".  A table of employees is an indexed
   container that contains one employee per defined index.</p><p>Tables, trees and the graphs data structures are well
   documented on text books such as [<span class="citation">Knuth97</span>]
   [<span class="citation">Cormen01</span>], albeit with a different focus than
   ours. The associated data attributes associated with the topology
   are well described in databases -- where they are sometimes called
   tuples and managed as tables -- and in programming languages also
   provide simple means to define data types and aggregate them in
   compound structures such as tables, trees or graphs.  Advanced
   computer languages allow the definition of tables of employees,
   trees of employees or graph of employees related by some
   relationship.</p><p>These systems usually represent tables as an array of tuples
   where each tuple is a row and each attribute is a column.  They
   allow for easy insertion or deletion of new tuples, but don't allow
   the easy modification of the data structure.</p><p>The InfoVis Toolkit takes a different approach than databases
   tuples and language aggregated data structures: it uses "columns"
   internally so that new attributes can easily be added to existing
   data structures.  Inserting or removing rows is as easy as inserting
   or removing attributes.</p><p>This approach is important in Information Visualization as it
   is in spreadsheet calculators since several computations or
   visualizations require new values to be computed and
   manipulated.</p><p>In the next sections, we explain the main properties of a
   column and how it can be used.  We then describe how traditional
   data structures are built on top of the columns.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_columns"></a>Columns</h2></div></div><div></div></div><p>A column is an index container that contains a homogeneous
    data structure, such as integers, floating point values or string.
    Columns also manage <span class="emphasis"><em>Metadata</em></span>,
    <span class="emphasis"><em>notification</em></span> and <span class="emphasis"><em>undefined
     values</em></span>.</p><p><span class="interface">Column</span> is a Java interface
    with several concrete implementations. There are two derivation
    paths for columns, one is for concrete data types and the other one
    is for dense versus sparse columns.</p><p>Dense columns are based on primitive array, providing a
    constant access time and a memory footprint linear with the number
    of entries.  Sparse columns are based on sorted trees, providing a
    log(n) access time and a memory footprint linear with the number of
    defined entries.  They come specialized for the most used data
    types such as <span class="type">int</span>, <span class="type">long</span>,
    <span class="type">float</span>, <span class="type">double</span>, <span class="type">String</span>,
    <span class="type">Object</span>, <span class="type">bool</span> and some others used
    internally. </p><p>The interface of the <a href="api/infovis/Column.html" target="_top">
    <tt class="interfacename">Column</tt></a> should be described
    using an extended syntax with parameterized types to be complete.
    Each of the concrete class implementing the Column interface for
    storing an object of class TYPE should provide a set of methods
    using this concrete type.  For example, the IntColumn class
    implements all the methods with "TYPE" replaced by
    <span class="type">int</span> so the <tt class="methodname">get</tt> method
    returns an <span class="type">int</span>.</p><p>The Java language doesn't allow this kind of type
   parametrization yet &#8212; although a newer experimental version
   does &#8212; so the declaration doesn't express this requirement
   and the Java compiler doesn't enforce these methods, but we have
   worked hard to implement them and check them by hand.  If you want
   to implement a new kind of <tt class="interfacename">Column</tt>,
   you will also have to implement them.</p><p>The <a href="api/infovis/utils/RowComparator.html" target="_top">
     <tt class="interfacename">RowComparator</tt></a> interface
     allows elements to be compared and sorted without having to know
     their type.  It declares the
     <tt class="methodname">compare(int,int)</tt> method for comparing
     the values of two rows in the column. </p><p>The basic interface specifies that column elements can always
   be manipulated in their textual representations.  This is
   convenient for loading column contents from a textual file or
   saving them.  It also provides a representation for using the
   columns for labeling visualizations.  However, the real value
   stored in a concrete column can be of any type.</p><p>When the concrete type of the column is known, the concrete
    method, shown as parametrized in the interface, such as
    <tt class="methodname">get</tt> or<tt class="methodname">set</tt>, can
    be used to access the concrete values of the column elements.
    These methods are fast since they don't involve any allocation or
    transformation.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id4745096"></a>Presentation Format</h3></div></div><div></div></div><p>Transforming from <span class="type">String</span> values to internal
     values is performed by <tt class="classname">java.text.Format</tt>
     objects.  These objects can transform a <span class="type">String</span> into
     an <span class="type">Object</span> through the <tt class="methodname">parse</tt>
     method.  They can also transform an <span class="type">Object</span> into a
     <span class="type">String</span> through the <tt class="methodname">format</tt>
     method.  This mechanism is used internally by columns and can be
     extended by users if needed.</p><p>For example, date and time information associated to
    computer files is usually represented as a 32bits or 64bits
    integer value.  Storing file dates in a table or tree structure
     can be done either as a column of <span class="type">String</span> or as a
    column of <tt class="classname">long</tt>.  The later offer two
    advantages: it is more compact and dates can then be compared using
    standard integer comparison.  Translating from a standard date
    format such as the Unix date for files can be specified as follows:
  </p><div class="example"><a name="ex2_1"></a><p class="title"><b>Example 3.1. Creating a <tt class="classname">LongColumn</tt> Reading Dates
     in the Unix Format </b></p><pre class="programlisting">      LongColumn dateColumn = new LongColumn("date");
      dateColumn.setFormat(new UTCDateFormat());
      dateColumn.addValueOrNull("29 Oct 2003 21:47:32");

</pre></div><p>If the values are read as integers, maybe because they have
     been read directly from a function that return them as a
     <span class="type">long</span>, the format can still be specified but the
     value can now be added as a <span class="type">long</span> using the
     <tt class="methodname">add</tt> method.</p><p>Java Formats transform a string into an object or an object
    into a string.  to work in a Column, the format should return an
    object compatible with the concrete type of the column.  For
    example, number columns expect the object to be a Java
    <tt class="interfacename">Number</tt> to extract the value from
    it.  Ganeral Java Formats may not return the right kind of object,
    requiring the derivation of the Format class to return the propoer
    value.  This is what the <a href="api/infovis/column/UTCDateFormat.java" target="_top">UTCDataFormat</a>
    does for dates.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id4745238"></a>NumberColumns</h3></div></div><div></div></div><p>Very often, Columns contain number of different types such
    as integers, floats, long or doubles.  It is however very
    convenient to abstract the differences between these
    representation of numbers and manipulate them all in a similar
    way.  <tt class="classname">NumberColumn</tt> is an interface that
    allows columns holding numeric types to be manipulated in a
    similar way.  For example, when a visualization needs to map a
    number column to the X screen position, it usually applies a
    simple linear transformation to the values of the column,
    regardless of their concrete type.  Without the
    <tt class="classname">NumberColumn</tt> abstraction, the mapping would
    have to consider each concrete number type, which would be painful
    and error prone.  </p><p><tt class="classname">NumberColumn</tt> should define methods to
    get or set a row with all the Java number types.  These methods
    are <tt class="methodname">get&lt;TYPE&gt;at(int)</tt> and
    <tt class="methodname">set&lt;TYPE&gt;At(int,TYPE)</tt>.  The
    implementation should take care not to lose precision when
    possible.  The safest bet when getting values from a NumberColumn
    is to ask for a <span class="type">double</span>.  Only some <span class="type">long</span>
    values may loose precision when represented as a double.  Ideally,
    this should be checked but isn't currently.  When setting a value,
    it could be specified using its "natural" type to insure that the
    conversion will be as lossless as possible.</p><p>Methods are also defined to get the minimum and maximum
     values contained in the columns:
     <tt class="methodname">get&lt;TYPE&gt;Min()</tt> and
     <tt class="methodname">get&lt;TYPE&gt;Max()</tt>.  Finally, a
     <tt class="methodname">round(double)</tt> method returns the closest
     representation of a number for the column, as a double.  For
     example, on a column of integers, round(3.5) will return
     3.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id4745336"></a>Dense Columns</h3></div></div><div></div></div><p>Dense columns are based on primitive Java arrays.  For now,
    they use one large array but this may change for several array
    chunks to avoid copying large blocks when resizing the array.
    Access time and modification time are constant, not counting the
    time required to perform notification when the changing the
    values.</p><p>Undefined values are still allowed.  For columns containing
     object-values (non-literal values), undefined rows contain the
     <tt class="varname">null</tt> value.  For Column containing literal
     types, undefined rows are stored as integers in a balanced binary
     tree.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="sec_literal_columns"></a>Literal Columns: <tt class="classname">IntColumn</tt>,
      <tt class="classname">LongColumn</tt>,
      <tt class="classname">FloatColumn</tt> and
      <tt class="classname">DoubleColumn</tt></h4></div></div><div></div></div><p>Literal columns contain values considered as literal in
     Java: integers, longs, floating point values and double values.
     These number types are not objects but are much more efficient
     than general objects in term of storage and computation. This is
     why the Infovis Toolkit rely on them for efficiency. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id4745411"></a>BooleanColumn</h4></div></div><div></div></div><p><span class="type">Boolean</span> columns are literal columns containing
     boolean value.  They are also number columns, returning a 0 for a
     false value and a one for a true value.  They also implement the
     ListSelection interface acd+++ </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id4745427"></a>FilterColumn</h4></div></div><div></div></div><p></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id4745436"></a>StringColumn and ObjectColumn</h4></div></div><div></div></div><p></p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id4745447"></a>Sparse Columns</h3></div></div><div></div></div><p></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id4745457"></a>Column Dependencies</h3></div></div><div></div></div><p>The values of one column can be the result of a computation
     made from values taken from other columns.  The dependencies can
     be maintained so that each time an column value is modified, all
     the dependent columns are updated. </p><p>MORE TO COME</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_tables"></a>Tables</h2></div></div><div></div></div><p>Tables are the simplest data structure of the InfoVis
   toolkit.  A simple way to create and populate a table is:</p><pre class="programlisting">Table table = new DefaultTable();
table.setName("Cities");
StringColumn name = StringColumn.findColumn(table, "name");
IntColumn population = IntColumn.findColumn(table, "population");
name.add("New York");
population.add(2000000);
name.add("Los Angeles");
population.add(1000000);

</pre><div class="figure"><a name="fig_table"></a><p class="title"><b>Figure 3.1. The Table interface</b></p><pre class="classsynopsis"> <span class="ooclass"><span class="modifier">public </span><span class="classname">Table</span></span>implements <span class="oointerface"><span class="interfacename">Metadata</span></span>, <span class="oointerface"><span class="interfacename">TableModel</span></span> {<br>}</pre></div><p>The Table interface is described in <a href="#fig_table" title="Figure 3.1. The Table interface">Figure 3.1, &#8220;The Table interface&#8221;</a>.  A Table also manages Metadata and
   implements the TableModel interface, enabling its use in a standard
   Java Swing JTable.  Table defines methods to add/remove/access
   columns by name or index.  The <tt class="methodname">getRowCount</tt>
   method returns the maximum number of rows of each of the columns in
   the table; Tables don't maintain their own row counts.  The columns
   contained in a Table may have different row counts.  This is not a
   problem at all considering that columns can contain undefined rows;
   the row count of a table is indeed the largest row count and
   columns with less elements are considered as having undefined
   values at their ends.</p><p>The default implementation of the Table interface is the
   <tt class="classname">DefaultTable</tt> class.  Concrete
   implementations of <tt class="interfacename">Tree</tt> and
   <tt class="interfacename">Graph</tt> derive from this
   class. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_tree"></a>Trees</h2></div></div><div></div></div><div class="figure"><a name="fig_tree"></a><p class="title"><b>Figure 3.2. The Tree interface</b></p><pre class="classsynopsis"> <span class="ooclass"><span class="modifier">public </span><span class="classname">Tree</span></span>implements <span class="oointerface"><span class="interfacename">Table</span></span> {<br>}</pre></div><p>The InfoVis Toolkit implements rooted trees with the
   interface describe in <a href="#fig_tree" title="Figure 3.2. The Tree interface">Figure 3.2, &#8220;The Tree interface&#8221;</a>.  A Tree manages a
   topology and associated attributes, stored in columns.  Creating a
   file-system like tree can be done using this example
   program:</p><pre class="programlisting">    Tree tree = new DefaultTree();
    StringColumn name = StringColumn.findColumn(tree, "name");
    LongColumn date = LongColumn.findColumn(tree, "date");
    date.setFormat(new UTCDateFormat());
    
    name.setValueAt(Tree.ROOT, "/");
    date.setValueAt(Tree.ROOT, "29 Oct 2003 21:47:32");

    int n1 = tree.add(Tree.ROOT); // Child of tree root
    name.setValueAt(n1, ".classpath");
    date.setValueAt(n1, "23 Feb 2004 22:46:30");

    int n2 = tree.add(Tree.ROOT); // 2nd child of tree root
    name.setValueAt(n2, "CVS");
    date.setValueAt(n2, "6 May 2003 23:32:34");

    int n3 = tree.add(n2); // child of node n2
    name.setValueAt(n3, "Entries");
    date.setValueAt(n3, "24 Feb 2003 23:30:13");
</pre><p>A Tree is implemented as a Table.  Nodes are simply indexes.
    Currently, four internal columns are used to manage the topology.
    These columns can be read and even modified, but doing so would
    certainly break the structure so it should be avoided.  The
    internal columns are all <tt class="classname">IntColumn</tt>s.  Here
    is their description:</p><div class="variablelist"><dl><dt><span class="term">"#parent"</span></dt><dd><p>Contain the parent node for each node.  The first line in
      the following examples is equivalent to the next two
      lines:</p><pre class="programlisting">       int p = tree.getParent(node);

       IntColumn parentColumn = IntColumn.findColumn(tree, Tree.PARENT_COLUMN);
       int p = parentColumn.get(node);
</pre><p>The parent of the node <tt class="constant">Tree.ROOT</tt> is
       <tt class="constant">Tree.NIL</tt>.  All other valid nodes have
       non-nil parents. </p></dd><dt><span class="term">"#child"</span></dt><dd><p>Contains the first child of a node or
      <tt class="constant">Tree.NIL</tt> for a leaf node.</p></dd><dt><span class="term">"#next"</span></dt><dd><p>Contains the next sibling of nodes, or
      <tt class="constant">Tree.NIL</tt> if the node is the last child of a
      node.</p></dd><dt><span class="term">"#last"</span></dt><dd><p>Contains the last child of a node or
      <tt class="constant">Tree.NIL</tt> for a leaf node.  The last child
      of a node could be computed by following the siblings of the
      first child of a node but Maintaining the last node is faster.</p></dd></dl></div><p>Other internal columns can be maintained automatically by the
    <tt class="classname">DefaultTree</tt> implementation to speedup
    topological queries such as the depth of a node, its degree
    (number of children) or to access the children list faster.  The
    depth column is created and maintained using the method
    <tt class="methodname">createDepthColumn</tt>.  The degree column is
    created and maintained using the method
    <tt class="methodname">createDegreeColumn</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_graphs"></a>Graphs</h2></div></div><div></div></div><div class="figure"><a name="fig_graph"></a><p class="title"><b>Figure 3.3. The Graph interface</b></p><pre class="classsynopsis"> <span class="ooclass"><span class="modifier">public </span><span class="classname">Graph</span></span>implements <span class="oointerface"><span class="interfacename">Table</span></span> {<br>}</pre></div><p>Graphs are composed of two tables: a vertex table and a link
   table.  The first holds topological informations about the vertices
   and their associated attributes as columns.  The second holds the
   topological information about the links.  The Graph interface is
   described in <a href="#fig_graph" title="Figure 3.3. The Graph interface">Figure 3.3, &#8220;The Graph interface&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_metadata"></a>Metadata</h2></div></div><div></div></div><p><a class="indexterm" name="id4745926"></a>Metadata
    is information about the data.  Columns and tables can contain
    metadata implemented as an associative map between a key and a
    value, usually strings.  </p><p>There are many types of metadata; well known uses include the
   description of the dataset in term of a title, an author, a
   creation date, etc.  Another use could be describing the processing
   performed on a table or on a column to create it.  The InfoVis
   toolkit uses the metadata for several different purposes that we
   describe here with no particular order.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id4745955"></a>Standard Description</h3></div></div><div></div></div><p>It is useful to describe a dataset using standard and
    well-understood metadata categories. We use the Dublin Core
    metadata vocabulary, meant to standardize simple and useful
    description attributes.</p><p>MORE TO COME</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id4745973"></a>Aggregation</h3></div></div><div></div></div><p><a class="indexterm" name="id4745980"></a>Aggregation information
     applies to columns in a Tree.  Some columns only define values
     for the leaf nodes of the tree.  For example, when loading the a
     file directory in a Tree, InfoVis doesn't provide size
     information for directories, only for files.  However, we know
     what the file size of a directory means, it is the sum of the
     file sizes.  In that situation, the column containing the file
     sizes will have an aggregation metadata explaining just that: the
     file sizes add up with the hierarchy.</p><p>Adding up with the hierarchy is a common aggregation
     method, but others exist as well.  First, some column don't
     aggregate at all.  For example, the file names don't aggregate,
     but it turns out they are defined for all the directories so we
     don't need to invent a new name.  Usually, nominal and
     categorical information don't aggregate.  If your file have
     types, such as image or text, the directory cannot simply compute
     a similar category.  We will see later that we could still create
     an aggregation function in similar cases, but let's continue with
     simpler cases.</p><p>The InfoVis Toolkit defines seven well understood
     aggregation types: <i class="firstterm">additive</i>,
     <i class="firstterm">max</i>, <i class="firstterm">min</i>,
     <i class="firstterm">mean</i>, <i class="firstterm">concat</i>,
     <i class="firstterm">atleaf</i> and <i class="firstterm">none</i>.
     We have already discussed the additive type.  The "max", "min"
     and "mean" are similar.  "Max" computes the maximum over all the
     children as the aggregation function.  "Min" and "mean" compute
     the minimum and the mean respectively.  As an example, consider
     file dates in a directory tree.  If you are interested by
     finding the latests work performed, you want to aggregate dates
     on the maximum date value of each directory.</p><p>The "concat" type is for string values and simply specifies
     that the values will be concatenated into a string with a space
     between them.  Finally, the "atleaf" means that the attributes
     are only defined at the leaves, not for interior nodes.  In that
     case, any of the numeric aggregation function can be freely
     applied to the column if it is a numerical column, and the
     concatenation function can be applied in all cases.</p><p>There is one class defined to manage each aggregation
     function.  These classes are useful to compute the aggregated
     values of a column or checking whether a column belongs to one
     aggregation category.  Furthermore, new aggregation classes can
     be defined if you need it.  In that case, you will need to define
     how to recognize a column that aggregates using your function and
     to compute the function.  The
     <tt class="classname">AggregationCategory</tt> class is a factory for
     aggregation functions so you can add yours and it will be
     correctly applied.  </p><p>Aggregation information is stored with the
     <tt class="constant">AGGREGATION_TYPE</tt> metadata key.  The
     following constants are defined in
     <tt class="filename">infovis.metadata.AggregationConstants.java</tt>:
     </p><div class="itemizedlist"><ul type="disc"><li><p><tt class="constant">AGGREGATION_TYPE_NONE</tt></p></li><li><p><tt class="constant">AGGREGATION_TYPE_NONE</tt></p></li><li><p><tt class="constant">AGGREGATION_TYPE_ATLEAF</tt></p></li><li><p><tt class="constant">AGGREGATION_TYPE_ADDITIVE</tt></p></li><li><p><tt class="constant">AGGREGATION_TYPE_MAX</tt></p></li><li><p><tt class="constant">AGGREGATION_TYPE_MIN</tt></p></li><li><p><tt class="constant">AGGREGATION_TYPE_MEAN</tt></p></li><li><p><tt class="constant">AGGREGATION_TYPE_CONCAT</tt></p></li></ul></div><p>
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id4746200"></a>The Aggregation Class</h4></div></div><div></div></div><pre class="classsynopsis"> <span class="ooclass"><span class="modifier">public </span><span class="classname">Aggregation </span></span>implements <span class="oointerface"><span class="interfacename">AggregationConstants</span></span> {<br><code class="fieldsynopsis">  <span class="modifier">public static final </span><span class="type">short </span><span class="varname">AGGREGATE_NO </span><span class="initializer">= 0</span>;</code><br><code class="fieldsynopsis">  <span class="modifier">public static final </span><span class="type">short </span><span class="varname">AGGREGATE_YES </span><span class="initializer">= 1</span>;</code><br><code class="fieldsynopsis">  <span class="modifier">public static final </span><span class="type">short </span><span class="varname">AGGREGATE_COMPATIBLE </span><span class="initializer">= -1</span>;</code><br><code class="methodsynopsis">  <span class="modifier">public </span><span class="type">short </span><span class="methodname">isAggregating</span>(<span class="methodparam"><span class="parameter">Column col</span></span>);</code><br><code class="methodsynopsis">  <span class="modifier">public </span><span class="type">Column </span><span class="methodname">aggregate</span>(<span class="methodparam"><span class="type">Column </span><span class="parameter">src</span></span>,<br>                          <span class="methodparam"><span class="type">Tree </span><span class="parameter">tree</span></span>,<br>                          <span class="methodparam"><span class="type">Column </span><span class="parameter">dst</span></span>);</code><br>}</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id4746375"></a>Converting to Number Columns</h3></div></div><div></div></div><p></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id4746384"></a>Color Scheme Categories</h3></div></div><div></div></div><p></p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="chap_visualizations"></a>Chapter 4. Visualizations</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id4746460">Implementation of the Visualization Classes</a></span></dt><dd><dl><dt><span class="section"><a href="#id4746771">Displaying Items in Visualizations</a></span></dt><dt><span class="section"><a href="#id4747074">Visual Column Management</a></span></dt><dt><span class="section"><a href="#sec_color">Color Management</a></span></dt><dt><span class="section"><a href="#id4747106">Picking</a></span></dt></dl></dd><dt><span class="section"><a href="#id4747117">Table Visualizations</a></span></dt><dt><span class="section"><a href="#id4747126">Stroking and Link Visualizations</a></span></dt><dt><span class="section"><a href="#id4747136">Tree Visualizations</a></span></dt><dt><span class="section"><a href="#id4747146">Graph Visualizations</a></span></dt><dt><span class="section"><a href="#id4747155">Dynamic Labeling</a></span></dt><dt><span class="section"><a href="#id4747165">Fisheye Lenses</a></span></dt></dl></div><p>Visualizations transform a data structure into a visual
  representation, allowing exploration and interaction.  To create the
  visual representation, a visualization relies on the topology of the
  data structure and a set of attributes implemented as columns in the
  data structure. </p><p>More formally, a visualization creates one graphical mark for
  each table row.  This mark is defined by a shape, position,
  color and transparency.  The shape itself can be decomposed into a
  basic shape, a size and a position.  These attributes altogether are
  called visual attributes.  </p><p>All visualizations implement the interface
   <a href="api/infovis/Visualization.html" target="_top">
   <tt class="interfacename">Visualization</tt></a>.  A
  visualization is always related to one and only one table and should
  be installed in a Java <tt class="classname">JComponent</tt> to show in
  a window.  The InfoVis toolkit provides the
  <tt class="classname">VisualizationPanel</tt> for that purpose.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id4746460"></a>Implementation of the Visualization Classes</h2></div></div><div></div></div><p>The main implementation of the
    <tt class="interfacename">Visualization</tt> interface is the
    <tt class="classname">DefaultVisualization</tt> class.  All the
    specific visualizations derive from it.</p><p>When a visualization is created, it should be configured to
    map table columns to visual columns.  Visualizations use several
    types of visual properties, some being standard and some being
    specific to a visualization technique.  The standard visual
    properties are the following:
    </p><div class="variablelist"><dl><dt><span class="term">Color</span></dt><dd><p>The column used to specify the color of items.  For
	example, if the visualized table contains a number column named
	"length", using it for coloring the items can be done in the
	following way:
	</p><pre class="programlisting">visualization.setVisualColumn(
	 Visualization.VISUAL_COLOR, table.getColumn("length"));
	 
	</pre><p>Section <a href="#sec_color" title="Color Management">the section called &#8220;Color Management&#8221;</a> provides more details
	on the mechanisms for color management.</p><p>The constant string
	<tt class="constant">Visualization.VISUAL_COLOR</tt> contains the
	name of the visual column for colors.</p><p>When no column is mapped to the color visual attribute, a
	default color is used, specified by the
	<tt class="methodname">setDefaultColor(Color)</tt> method.</p></dd><dt><span class="term">Size</span></dt><dd><p>The column used to specify the size of items.  Sizes have
	different meaning depending on the specific visualization.  For
	Treemaps, it is the taken as the relative size of Treemap
	rectangles.  On scatter plots, it controls the size of each item
	varying from a minimum and maximum size specific to the scatter
	plot visualization class.</p><p>The constant string
	<tt class="constant">Visualization.VISUAL_SIZE</tt> contains the
	name of the visual column for sizes.</p><p>When no column is mapped to the size visual attribute, a
	default size is used, specified by the
	<tt class="methodname">setDefaultSize(double)</tt> method.</p></dd><dt><span class="term">Alpha</span></dt><dd><p>The column used to specify the transparency or Alpha
	channel of items.  The constant string
	<tt class="constant">Visualization.VISUAL_ALPHA</tt> contains the
	name of the visual column for transparencies.</p><p>When no column is mapped to the alpha visual attribute, a
	default alpha values is used, specified by the
	<tt class="methodname">setDefaultAlpha(double)</tt> method.</p></dd><dt><span class="term">Label</span></dt><dd><p>The column used to specify the name or label or items. The
	constant string <tt class="constant">Visualization.VISUAL_LABEL</tt>
	contains the name of the visual column for
	labels.</p><p>When no column is mapped to the label visual attribute,
	the items are labeled "item" and the item number.</p></dd></dl></div><p>
   </p><p>Other attributes can be specified using the same mechanism,
    although they are not "visual" attributes per se.  These attributes
    are:
    </p><div class="variablelist"><dl><dt><span class="term">Selection</span></dt><dd><p>The column used to specify which items are selected. The
	constant string
	<tt class="constant">Visualization.VISUAL_SELECTION</tt> contains the
	name of the visual column for selection.  It should be a boolean
	column.  One important use of this column is to share selection
	among several visualizations showing the same table.</p><p>When no column is mapped to the selection visual attribute,
	a new selection column is created.</p></dd><dt><span class="term">Filter</span></dt><dd><p>The column used to specify which items are filtered. The
	constant string <tt class="constant">Visualization.VISUAL_FILTER</tt>
	contains the name of the visual column for filtering.  It should
	be a <tt class="classname">FilterColumn</tt>.  One important use of
	this column is to share selection among several visualizations
	showing the same table.</p><p>When no column is mapped to the filter visual attribute,
	a new filter column is created.</p></dd><dt><span class="term">Sort</span></dt><dd><p>The column used to specify the item order in the
	visualization.  The constant string
	<tt class="constant">Visualization.VISUAL_SORT</tt> contains the
	name of the visual column for sorting. </p><p>When no column is mapped to the sort visual attribute,
	the items are visualized in the table order.</p></dd></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id4746771"></a>Displaying Items in Visualizations</h3></div></div><div></div></div><p>Displaying items is performed through several steps, each
     being configurable or modifiable by class derivation.  
     </p><div class="variablelist"><dl><dt><span class="term">Layout</span></dt><dd><p>This steps compute a shape for each visualized item.  A
	 <tt class="interfacename">Shape</tt> is a Java interface that
	 describes a general geometry.  Specific visualizations can
	 decide to limit the shapes they compute and position to
	 rectangles or squares.  For that purpose, a Java
	 <tt class="classname">Rectangle2D</tt> implements the
	 <tt class="interfacename">Shape</tt> interface.</p><p>The computed shapes will be used for displaying the
	 items and for hit detection when the mouse pointer moves over
	 displayed items.  The computed shapes are stored in a visual column
	 called <tt class="constant">Visualization.VISUAL_SHAPE</tt> and
	 can be queried from outside the visualization if
	 required.</p><p>The method used to compute the layout is called
	 <tt class="methodname">computeShapes</tt> and is triggered when
	 the layout needs to be computed.  The method is called just
	 before painting or hit detection when either of the following
	 events occurred:
	 </p><div class="itemizedlist"><ul type="disc"><li><p>The visualization has just been displayed on screen,
	    no layout has been computed before;</p></li><li><p>A visual column involved in computing the layout has
	    been associated with a new table column;</p></li><li><p>A visual column involved in computing the layout has
	    been modified.</p></li></ul></div><p>
	</p><p>There is no automatic way to guess whether a visual
	 column is used for computing the layout; it should be specified
	 by each specific visualization class for each visual column.
	 This is usually done from the constructor of the visualization
	 class by calling the method
	 <tt class="methodname">setVisualColumnInvalidate(String,boolean)</tt>.
	 When the second argument is <tt class="constant">true</tt>, changing
	 the specified column will trigger a recomputation of the
	 layout.  When it is <tt class="constant">false</tt>, the
	 visualization will be redisplayed without changing its
	 layout.</p><p>By default, the "color" visual attribute does not
	trigger a layout recomputation whereas the "size" attribute
	does trigger a layout recomputation.  Stroke-based
	visualizations such as time series or parallel visualizations
	change the latter because the size only change the stroke
	thickness, not the shape geometry so changing the size visual
	column only need to trigger a redisplay, the geometry of
	shapes shall not change.</p></dd><dt><span class="term">Items display</span></dt><dd><p>When the shapes have been computed, the items can be
	displayed one at a time, in the sorting order, using the
	shapes for the geometry and other visual columns for visual
	 attributes.  The default implementation uses the
	<tt class="methodname">paintItems(Graphics2D g,Rectangle2D
	bounds)</tt> implemented as follows:
	 </p><pre class="programlisting">            for (RowIterator iter = iterator(); iter.hasNext();) {
                int row = iter.nextRow();
                if (isFiltered(row))
                    continue;
                paintItem(graphics, row);

</pre><p>
	</p><p>The method uses a
	<tt class="interfacename">RowIterator</tt> to iterate over all
	 the items in sorting order, skip the filtered items using the
	 <tt class="methodname">isFiltered(int row)</tt> method and
	 draws the items using the <tt class="methodname">paintItem(Graphics2D
	g,int row)</tt> method.</p><p>The method can be overridden in a derived class if, for
	example, the visualization wants to grey-out the filtered
	items.</p></dd><dt><span class="term">Item Display</span></dt><dd><p>Displaying an item needs several steps: installing all
	the graphic attributes, transforming the shape by a fisheye
	lens, drawing the shape, drawing its outline and drawing a
	 label.  Each of these steps are done inside the
	<tt class="methodname">paintItem(Graphics2D g, int row)</tt>
	method as follow:
	 </p><pre class="programlisting">        Shape s = getShapeAt(row);
        if (s == null)
            return;
        s = transformShape(s);

        installAlpha(graphics, row);
        installColor(graphics, row, s);
        displayedItems++;
        paintShape(graphics, row, s);
        paintOutline(graphics, row, s);
        paintLabel(graphics, row, s);

</pre><p>
	</p><p>All of the called methods can be overridden by
	 subclasses if required.  For example, the
	 <tt class="classname">StrokingVisualization</tt> class interprets
	 shapes as stroked instead of filled.  It redefines the
	 <tt class="methodname">paintShape</tt> method as doing nothing
	 and the paintOutline as drawing the shape using either red if
	 the item is selected or the selected color otherwise as
	 follows:
	 </p><pre class="programlisting">    public void paintOutline(Graphics2D graphics, int row, Shape s) {
        if (selection != null
            &amp;&amp; (!selection.isValueUndefined(row))
            &amp;&amp; selectedColor != null) {
            graphics.setColor(selectedColor);
        }
        installSize(graphics, row);
        graphics.draw(s);
        graphics.setStroke(savedStroke);
    }

</pre><p>
</p></dd></dl></div><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id4747074"></a>Visual Column Management</h3></div></div><div></div></div><p>Visual columns are used internally by visualizations to compute
     the mapping between table rows and visual marks.  They are also
     managed to trigger redisplays when one of the visual column has
     changes.  </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sec_color"></a>Color Management</h3></div></div><div></div></div><p>Color is managed using several mechanisms inside
     visualizations. +++</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id4747106"></a>Picking</h3></div></div><div></div></div><p></p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id4747117"></a>Table Visualizations</h2></div></div><div></div></div><p></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id4747126"></a>Stroking and Link Visualizations</h2></div></div><div></div></div><p></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id4747136"></a>Tree Visualizations</h2></div></div><div></div></div><p></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id4747146"></a>Graph Visualizations</h2></div></div><div></div></div><p></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id4747155"></a>Dynamic Labeling</h2></div></div><div></div></div><p></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id4747165"></a>Fisheye Lenses</h2></div></div><div></div></div><p></p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="chap_interaction"></a>Chapter 5. Interaction</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id4747190">Dynamic Queries</a></span></dt></dl></div><p>Direct through Picking, indirect through columns </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id4747190"></a>Dynamic Queries</h2></div></div><div></div></div><p></p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="readerswriters"></a>Chapter 6. Readers and Writers</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id4747213">Table Readers and Writers</a></span></dt><dt><span class="section"><a href="#id4747222">Tree Readers and Writers</a></span></dt><dt><span class="section"><a href="#id4747232">Graph Readers and Writers</a></span></dt></dl></div><p></p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id4747213"></a>Table Readers and Writers</h2></div></div><div></div></div><p></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id4747222"></a>Tree Readers and Writers</h2></div></div><div></div></div><p></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id4747232"></a>Graph Readers and Writers</h2></div></div><div></div></div><p></p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id4747242"></a>Chapter 7. Design Patterns</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id4747250">Abstract Factory</a></span></dt><dt><span class="section"><a href="#id4747260">Observer</a></span></dt><dt><span class="section"><a href="#id4747269">Visitor</a></span></dt></dl></div><p></p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id4747250"></a>Abstract Factory</h2></div></div><div></div></div><p></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id4747260"></a>Observer</h2></div></div><div></div></div><p></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id4747269"></a>Visitor</h2></div></div><div></div></div><p></p></div></div><div class="index"><div class="titlepage"><div><div><h2 class="title"><a name="id4747282"></a>Index</h2></div></div><div></div></div><div class="index"><div class="indexdiv"><h3>A</h3><dl><dt>Aggregation, <a href="#id4745973">Aggregation</a></dt></dl></div><div class="indexdiv"><h3>F</h3><dl><dt>factory object, <a href="#sec_starting_infovis">Starting with the InfoVis Toolkit</a></dt></dl></div><div class="indexdiv"><h3>M</h3><dl><dt>Metadata, <a href="#sec_metadata">Metadata</a></dt></dl></div><div class="indexdiv"><h3>V</h3><dl><dt>visualization layer, <a href="#sec_using_fisheyes">Using Fisheye Lenses or Dynamic Labeling</a></dt></dl></div></div></div></div></body></html>
